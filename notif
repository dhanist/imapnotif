#!/usr/bin/env python3

import gi
import socket, select
gi.require_version('Notify', '0.7')
gi.require_version('Gtk', '3.0')
from gi.repository import Notify, GLib
import configparser
import argparse
import imaplib
import os, sys, logging, logging.handlers
import email
from html import escape as html_escape
import time
import resource, signal
from pwd import getpwnam
from threading import Thread
import ssl

'''
Please secure the config file with chmod 600 as this program runs
non interactive so we need to read plaintext password
'''
CONFIG_FILE     = "%s/.notif.cfg" % (os.environ["HOME"])
DEVLOG          = "/dev/log"
# DEVNULL         = "/dev/null"
DEVNULL         = "/home/dhani/void/log"
DEFAULT_MAILBOX = "INBOX"
INTERVAL        = 10
IDLE_TIMEOUT    = 15        # when using imap idle, value in minute
DEFAULT_UID     = 1000
VERBOSE         = True
DEBUG           = True
ACCOUNT_REF     = []        # holding account isntances

'''
for storing and tracking checked email numbers
collisions will occur every MAX_BYTE * 8 times.
'''
MAX_BYTE        = 128

class Track:
    def __init__(self):
        self._mnum = bytearray(MAX_BYTE)

    def set_bit(self, num):
        i = num % (MAX_BYTE * 8)
        self._mnum[i >> 3] |= (1 << (i % 0x07))

    def ck_bit(self, num):
        i = num % (MAX_BYTE * 8)
        if self._mnum[i >> 3] & (1 << (i % 0x07)) > 0:
            return True
        return False

    def clr_bit(self, num):
        i = num % (MAX_BYTE * 8)
        self._mnum[i >> 3] &= ~(1 << (i % 0x07))


class Account:
    def __init__(self, account):
        self._account    = account
        self._track      = Track()
        self._threads    = []
        self._is_running = True
        self.name        = account['name']

    def loop(self):
        mboxes = self._account["mailboxes"].split(',')
        for m in mboxes:
            mbox = Mbox(self._account, m.strip(), self._track)
            T = Thread(target=self.mon_mbox, args=(mbox,))
            T.start()
            self._threads.append(mbox)

            if T.is_alive() and VERBOSE:
                log.info("%s: thread for folder %s started" % (self._account["name"], m))

    def mon_mbox(self, mbox):
        while 1:
            sec = time.localtime().tm_sec
            imap = mbox.imap_init()
            if imap is None:
                if VERBOSE:
                    log.info("%s - %s: socket hasn't created" % (self._account["name"], mbox.name))
                time.sleep(60 - sec)
                continue

            if 'IDLE' in imap.capabilities:
                if VERBOSE:
                    log.info("%s - %s: trying imap idle" % (self._account["name"], mbox.name))
                while mbox.state & Mbox.IDLE_FAILED == 0:
                    if not self._is_running:
                        break
                    mbox.do_idle()

            if not self._is_running:
                break
            if mbox.state & Mbox.SOCK_ERR > 0:
                continue

            if VERBOSE:
                log.info("%s - %s: idle failed, will try to poll" % (self._account["name"], mbox.name))

            mbox.do_poll()
            time.sleep(60 - sec)

        if VERBOSE:
            log.info("%s - %s: thread exiting" % (self._account["name"], mbox.name))

    def close(self):
        self._is_running = False
        for mbox in self._threads:
            if VERBOSE:
                log.info("  --> closing mailbox thread %s" % (mbox.name))
            Thread(target=mbox.close, args=()).start()

class Notif:
    def __init__(self, **kwargs):
        self._data = kwargs.get("data")
        self._summ = kwargs.get('summary')
        self._body = kwargs.get('body')
        self._icon = kwargs.get('icon')
        self._func = kwargs.get('callback')

        self._notif = Notify.Notification.new(self._summ, self._body)
        self._notif.add_action("click", "Mark read", self._callback, self._data)

    def _callback(self, notif, act, data):
        self._func(data)

    def show(self):
        self._notif.show()

class Mbox:
    IDLE_FAILED = 0x01
    IDLE        = 0x02
    LOCKED      = 0x04
    SOCK_ERR    = 0x08
    EXITED      = 0x10

    def __init__(self, account, mbox, track):
        self.name    = mbox
        self._imap    = None
        self._account = account
        self.state    = 0
        self._track = track

    def close(self):
        self.state |= self.LOCKED
        try:
            if self.state & self.SOCK_ERR == 0:
                self._send_done()
                if self._read_response('any', 10) is not None:
                    self._imap.close()
                    self._imap.logout()
        except: pass

        if not self._imap.file.closed:
            self._imap.file.close()
            self._imap.sock.shutdown(socket.SHUT_RDWR)

        self.state &= ~self.LOCKED

    def imap_init(self):
        '''
        Initiate connection and returns imaplib.IMAP4 or imaplib.IMAP4_SSL instance
        '''

        self.state &= 0

        try:
            if "ssl" in self._account and int(self._account["ssl"]) == 1:
                    self._imap = imaplib.IMAP4_SSL(self._account["server"])
            else:   self._imap = imaplib.IMAP4(self._account["server"])
        except Exception as e:
            if VERBOSE:
                log.info("No network connectivity, will try again later")
            if DEBUG:
                log.info("Error initializing connection:\n%s" % (e))
            return None

        if not isinstance(self._imap, imaplib.IMAP4_SSL):
            if 'STARTTLS' in self._imap.capabilities:
                ssl_ctx = ssl.create_default_context()
                if VERBOSE: log.info("%s - %s: Escalate connection to use TLS" % (self._account["name"], self.name))
                try: self._imap.starttls(ssl_context=ssl_ctx)
                except: log.warning("%s - %s: STARTTLS failed" % (self._account["name"], self.name))

        try:
            self._imap.login(self._account["user"], self._account["password"])
        except:
            log.warning("%s - %s: Unable to login to server" % (self._account["name"], self.name))
            return None

        self._imap.select(self.name)
        return self._imap

    def do_idle(self):
        self._send_idle()

        if self.state & self.IDLE == 0:
            if VERBOSE:
                log.info("%s - %s: idle failed" % (self._account["name"], self.name))
            self.state |= self.IDLE_FAILED
            return

        if VERBOSE:
            log.info("%s - %s: idling.." % (self._account["name"], self.name))

        while 1:
            if self.state & self.SOCK_ERR > 0:
                log.info("%s - %s: socket error" % (self._account["name"], self.name))
                self.state |= self.IDLE_FAILED
                return

            if self.state & self.IDLE == 0:
                self.state &= ~self.IDLE_FAILED
                return

            socks = select.select([self._imap.sock], [], [], IDLE_TIMEOUT * 60)
            while self.state & self.LOCKED > 0:
                time.sleep(1)
                if DEBUG:
                    log.info("%s - %s:socket locked, waiting" % (self._account["name"], self.name))

                if self.state & self.SOCK_ERR > 0:
                    break

            if len(socks[0]) == 0:
                self._send_done()
                try:
                    if self._read_response('idle', 10) is not None:
                        self.state &= ~self.IDLE_FAILED
                        if VERBOSE:
                            log.info("%s - %s: Renewing idle mode" % (self._account["name"], self.name))
                        return
                except: pass
                self.state |= self.IDLE_FAILED
                log.info("timout waiting on socket")

            try:
                data = self._read_response('exists', 1)
                if data is not None:
                    if VERBOSE:
                        log.info("%s - %s: New message available" % (self._account["name"], self.name))
                    index = data[1]

                    self._send_done()
                    self._read_response('any', 5)
                    msg = self._fetch(index)
                    if msg is not None:
                        self._notify(msg)
                        self._track.set_bit(int(index))
                else:
                    continue
            except Exception as e:
                self.state |= self.IDLE_FAILED

            return


    def do_poll(self):
        # delay execution to align with time
        sec = time.localtime().tm_sec
        if sec > 0:
            time.sleep(60 - sec)

        mins = time.localtime().tm_min
        if mins % self._account["interval"] > 0:
            return

        self._imap.noop()
        socks = select.select([self._imap.sock], [], [], 30)
        if len(socks[0]) == 0:
            if DEBUG:
                log.info("%s - %s: socket not responding, will not do poll")
            return
        typ, data = self._imap.search(None, 'UNSEEN')

        for i in data[0].split():
            if self._track.ck_bit(int(i)):
                continue

            msg = self._fetch(i)
            if msg is not None:
                self._notify(msg)
                self._track.set_bit(int(i))

        self._imap.close()
        self._imap.logout()

    def _read_response(self, what, timeout):
        if self._imap.sock.fileno() < 0:
            self.state |= self.SOCK_ERR
            raise EOFError("Negative file descriptor")

        socks = select.select([self._imap.sock], [], [], timeout)
        if len(socks[0]) == 0:
            self.state |= self.SOCK_ERR
            raise IOError("socket timeout")

        while 1:
            socks = select.select([self._imap.sock], [], [], 1)
            if len(socks[0]) == 0:
                return None

            if self._imap.file.closed:
                break
            resp = self._imap.file.readline()
            if len(resp) == 0:
                if DEBUG:
                    log.info("%s - %s: Connection terminated by the server" % (self._account["name"], self.name))
                break

            data = resp.lower().split()

            if what == 'any':
                return data

            if bytes(what.lower(), 'ascii') in data:
                return data

        self.state |= self.SOCK_ERR
        raise EOFError("read on closed socket")

    def _send_done(self):
        self._imap.sock.sendall(b'DONE\r\n')
        self.state &= ~self.IDLE

    def _send_idle(self):
        self.state |= self.LOCKED
        self.state &= ~self.IDLE
        tag = self._imap._new_tag()

        try:
            self._imap.sock.sendall(b'%s IDLE\r\n' % (tag))
            if self._read_response('idling', 10) is not None:
                self.state |= self.IDLE
        except: pass

        self.state &= ~self.LOCKED


    def _fetch(self, index):
        '''
        Fetch header if haven't checked already
        return {'index': 'msg_index', 'sender': '', 'subject': ''} or None if skipped
        '''

        if self._track.ck_bit(int(index)):
           return None

        resp = {}

        typ, data = self._imap.fetch(index, '(BODY.PEEK[HEADER.FIELDS (SUBJECT FROM)])')
        msg = email.message_from_bytes(data[0][1])
        resp["index"] = index
        resp["from"]= html_escape(msg["from"].split('<')[0].replace("\"", "").strip())
        resp["subject"] = html_escape(msg["subject"]).strip()

        return resp

    def _mark_as_read(self, index):
        tag = self._imap._new_tag()

        self.state |= self.LOCKED
        try:
            if self.state & self.IDLE > 0:
                self._send_done()

            self._imap.sock.sendall(b'%s STORE %s +FLAGS \\Seen\r\n' % (tag, index))
        except: pass

        self.state &= ~self.LOCKED

    def _notify(self, data):
        summ = "%s: %s" % (self._account["name"], self.name.strip("\""))
        body = "%s\n\n%s" % (data["from"], data["subject"])

        Notif(summary=summ, body=body,data=data["index"], callback=self._mark_as_read).show()

log = logging.getLogger(__name__)
log.setLevel(logging.DEBUG)
handler = logging.handlers.SysLogHandler(address = DEVLOG)
handler.setFormatter(logging.Formatter('%(module)s: %(message)s'))
log.addHandler(handler)

parser = argparse.ArgumentParser(description="IMAP Desktop Notification")
parser.add_argument("-c", "--config", help="configuration file")
parser.add_argument("-u", "--user", help="Run daemon as user")
args = parser.parse_args()

if args.user:
        try:    uid = getpwnam(args.user).pw_uid
        except: pass
else:   uid = DEFAULT_UID

def close_imap(signum, blah=None):
    force = False

    if GLib.MainLoop().is_running():
        GLib.MainLoop().quit()

    if VERBOSE:
        log.info("Receiving signal number %d, exiting..." % (signum))

    if len(ACCOUNT_REF) == 0:
        sys.exit(0)

    for A in ACCOUNT_REF:
        if VERBOSE:
            log.info("Closing account %s" % (A.name))
        A.close()

    if force:
        log.info("Sockets not responding, force closing..")

    time.sleep(5)


def build_config():
    l = []

    if args.config:
            cfg_file = args.config
    else:   cfg_file = CONFIG_FILE
    cfg = configparser.ConfigParser()
    try:
        cfg.read(cfg_file)
    except:
        os.stderr.write("Unable to read config file, exiting..\n")
        sys.exit(1)

    for i in cfg.sections():
        d = {}
        d["name"] = i

        opts = cfg.options(i)
        for opt in opts:
            try:
                d[opt] = cfg.get(i, opt)
            except:
                d[opt] = None

        if not "mailboxes" in d or d["mailboxes"] == "":
            d["mailboxes"] = DEFAULT_MAILBOX

        if "interval" in d:
            try:
                    d["interval"] = int(d["interval"])
            except: d["interval"] = INTERVAL
        else:
            d["interval"] = INTERVAL

        if not "server" in d or d["server"] == "":
            sys.stderr.write("%s will not be checked: " % d["name"])
            sys.stderr.write("server not defined in config file\n")
            continue
        if not "user" in d or d["user"] == "":
            sys.stderr.write("%s will not be checked: " % d["name"])
            sys.stderr.write("user not defined in config file\n")
            continue
        if not "password" in d or d["password"] == "":
            sys.stderr.write("%s will not be checked: " % d["name"])
            sys.stderr.write("password not defined in config file\n")
            continue

        l.append(d)

    return l

def daemonize():
    try:
        pid = os.fork()
    except Exception as e:
        os.stderr.write("%s\n" % (e))
        sys.exit(1)

    if pid == 0:
        os.setsid()

        try:
            pid = os.fork()
        except Exception as e:
            os.stderr.write("%s\n" % (e))
            sys.exit(1)

        if pid == 0:
            os.chdir("/")
            os.umask(0)
        else:
            os._exit(0)

    else:
        os._exit(0)

    if os.getuid() == 0:
        os.setuid(uid)

    fd = resource.getrlimit(resource.RLIMIT_NOFILE)[1]
    if fd == resource.RLIM_INFINITY:
        fd = MAXFD

    sys.stdout.flush()
    sys.stderr.flush()

    devnull = os.open(DEVNULL, os.O_RDWR)

    os.dup2(devnull, sys.stdin.fileno())
    os.dup2(devnull, sys.stdout.fileno())
    os.dup2(devnull, sys.stderr.fileno())

accounts = build_config()
if len(accounts) == 0:
    sys.stderr.write("No accounts defined, exiting..\n")
    sys.exit(1)

signal.signal(signal.SIGTERM, close_imap)
signal.signal(signal.SIGINT, close_imap)
GLib.unix_signal_add(GLib.PRIORITY_HIGH, signal.SIGINT, close_imap, signal.SIGINT)
GLib.unix_signal_add(GLib.PRIORITY_HIGH, signal.SIGTERM, close_imap, signal.SIGTERM)

daemonize()

Notify.init(__name__)

for account in accounts:
    T = Account(account)
    T.loop()
    ACCOUNT_REF.append(T)

GLib.MainLoop().run()
