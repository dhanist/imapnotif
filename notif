#!/usr/bin/env python3

import gi
import socket, select
gi.require_version('Notify', '0.7')
from gi.repository import Notify
import configparser
import argparse
import imaplib
import os, sys, logging, logging.handlers
import email
from html import escape as html_escape
import time
import resource, signal
from pwd import getpwnam
from threading import Thread
import ssl

'''
Please secure the config file with chmod 600 as this program runs
non interactive so we need to read plaintext password
'''
CONFIG_FILE     = "%s/.notif.cfg" % (os.environ["HOME"])
DEVLOG          = "/dev/log"
DEVNULL         = "/dev/null"
DEFAULT_MAILBOX = "INBOX"
INTERVAL        = 10
MAXFD           = 1024
DEFAULT_UID     = 1000
VERBOSE         = False
THREADS         = []

'''
for storing and tracking checked email numbers
collisions will occur every MAX_BYTE * 8 times.
'''
MAX_BYTE        = 128

class Track:
    def __init__(self):
        self._mnum = bytearray(MAX_BYTE)

    def set_bit(self, num):
        i = num % (MAX_BYTE * 8)
        self._mnum[i >> 3] |= (1 << (i % 0x07))

    def ck_bit(self, num):
        i = num % (MAX_BYTE * 8)
        if self._mnum[i >> 3] & (1 << (i % 0x07)) > 0:
            return True
        return False

    def clr_bit(self, num):
        i = num % (MAX_BYTE * 8)
        self._mnum[i >> 3] &= ~(1 << (i % 0x07))


class Account:
    EXIT_STATE = False

    def __init__(self, account):
        self._account =  account
        self._track = Track()

    def loop(self):
        mboxes = self._account["mailboxes"].split(',')
        for mbox in mboxes:
            mbox = mbox.strip()
            T = Thread(target=self.mon_mbox, args=(mbox,))
            try:
                T.start()
            except: pass

            if T.is_alive() and VERBOSE:
                log.info("%s: thread for folder %s started" % (self._account["name"], mbox))

    def mon_mbox(self, mbox):
        while 1:
            try:
                if "ssl" in account and int(account["ssl"]) == 1:
                        imap = imaplib.IMAP4_SSL(account["server"])
                else:   imap = imaplib.IMAP4(account["server"])

                break
            except:
                if VERBOSE:
                    log.info("No network connectivity, will try again later")
                time.sleep(30)

        THREADS.append(imap)

        if not isinstance(imap, imaplib.IMAP4_SSL):
            if 'STARTTLS' in imap.capabilities:
                ssl_ctx = ssl.create_default_context()
                if VERBOSE: log.info("%s - %s: Escalate connection to use TLS" % (self._account["name"], mbox))
                try: imap.starttls(ssl_context=ssl_ctx)
                except: log.warning("%s - %s: STARTTLS failed" % (self._account["name"], mbox))

        try:
            imap.login(self._account["user"], self._account["password"])
        except:
            log.warning("%s - %s: Unable to login to server" % (self._account["name"], mbox))
            return

        imap.select(mbox, readonly=1)

        if 'IDLE' in imap.capabilities:
            if VERBOSE: log.info("%s - %s: will try  to use idle" % (self._account["name"], mbox))

            while 1:
                if self.EXIT_STATE:
                    break

                tag = imap._new_tag()
                try:
                    imap.sock.sendall(b'%s IDLE\r\n' % (tag))
                except:
                    log.warning("%s - %s: Error sending command idle" % (self._account["name"], mbox))
                    break

                while 1:
                    try:
                        resp = imap.file.readline()
                    except:
                        if VERBOSE:
                            log.info("%s - %s: thread exiting" % (self._account["name"], mbox))
                        return

                    if self.EXIT_STATE:
                        break

                    data = resp.lower().split()

                    if b'idling' in data:
                        if VERBOSE:
                            log.info("%s - %s: Entering idle state" % (self._account["name"], mbox))

                    if b'exists' in data:
                        if VERBOSE:
                            log.info("%s - %s: New message available" % (self._account["name"], mbox))
                        index = data[1]
                        try:
                            imap.sock.sendall(b'DONE\r\n')
                        except:
                            log.warning("Error sending command DONE")
                            break

                        msg = self.fetch(imap, index)
                        if msg is not None:
                            self.notify(mbox, msg)
                            self._track.set_bit(int(index))

                        break

        socks = select.select([imap.sock], [], [], 5)
        if len(socks[0]) > 0:
            if VERBOSE:
                log.info("%s - %s: Closing mailbox" % (self._account["name"], mbox))
            imap.close()
            imap.logout()

        if self.EXIT_STATE:
            if VERBOSE:
                log.info("%s - %s: thread exiting" % (self._account["name"], mbox))
            return

        if VERBOSE:
            log.info("%s - %s: idle failed, will try to poll" % (self._account["name"], mbox))

        # delay execution to align with time
        sec = time.localtime().tm_sec
        if sec > 0:
            time.sleep(60 - sec)

        while 1:
            if self.EXIT_STATE:
                break

            mins = time.localtime().tm_min
            if mins % self._account["interval"] > 0:
                time.sleep(60 - mins)
                continue

            if "ssl" in account and int(account["ssl"]) == 1:
                    imap = imaplib.IMAP4_SSL(account["server"])
            else:   imap = imaplib.IMAP4(account["server"])

            if not isinstance(imap, imaplib.IMAP4_SSL):
                if 'STARTTLS' in imap.capabilities:
                    ssl_ctx = ssl.create_default_context()
                    imap.starttls(ssl_context=ssl_ctx)

            try:
                imap.login(self._account["user"], self._account["password"])
            except:
                log.warning("Unable to login to server")

            imap.select(mbox, readonly=1)
            typ, data = imap.search(None, 'UNSEEN')

            for i in data[0].split():
                if self._track.ck_bit(int(i)):
                    continue

                msg = self.fetch(imap, i)
                if msg is not None:
                    self.notify(mbox, msg)
                    self._track.set_bit(int(i))

            M.close()
            M.logout()

        return True


    def fetch(self, imap, index):
        '''
        Fetch header if haven't checked already
        return {'sender': '', 'subject': ''} or None if skipped
        '''

        if self._track.ck_bit(int(index)):
           return None

        resp = {}

        typ, data = imap.fetch(index, '(BODY[HEADER.FIELDS (SUBJECT FROM)])')
        msg = email.message_from_bytes(data[0][1])
        resp["from"]= html_escape(msg["from"].split('<')[0].replace("\"", "").strip())
        resp["subject"] = html_escape(msg["subject"]).strip()

        return resp

    def notify(self, mbox, data):
        try:
            Notify.Notification.new("%s: %s" % (self._account["name"], mbox.strip("\"")),
                "%s\n\n%s" % (data["from"], data["subject"])).show()
        except Exception as e:
            log.warning(str(e))




log = logging.getLogger(__name__)
log.setLevel(logging.DEBUG)
handler = logging.handlers.SysLogHandler(address = DEVLOG)
handler.setFormatter(logging.Formatter('%(module)s: %(message)s'))
log.addHandler(handler)

parser = argparse.ArgumentParser(description="IMAP Desktop Notification")
parser.add_argument("-c", "--config", help="configuration file")
parser.add_argument("-u", "--user", help="Run daemon as user")
args = parser.parse_args()

if args.user:
        try:    uid = getpwnam(args.user).pw_uid
        except: pass
else:   uid = DEFAULT_UID

def close_imap(signum, blah):
    Account.EXIT_STATE = True
    if VERBOSE:
        log.info("Receiving signal number %d, exiting..." % (signum))

    i = 0
    for M in THREADS:
        if VERBOSE:
            log.info("Closing imap connection #%d" % (i))

        try:
            M.sock.sendall(b'DONE\r\n')
        except: pass
        socks = select.select([M.sock], [], [], 5)
        if len(socks[0]) == 0:
            log.info("Sockets not responding, force exiting..")
            sys.exit(0)

        i += 1

def build_config():
    l = []

    if args.config:
            cfg_file = args.config
    else:   cfg_file = CONFIG_FILE
    cfg = configparser.ConfigParser()
    try:
        cfg.read(cfg_file)
    except:
        os.stderr.write("Unable to read config file, exiting..\n")
        sys.exit(1)

    for i in cfg.sections():
        d = {}
        d["name"] = i

        opts = cfg.options(i)
        for opt in opts:
            try:
                d[opt] = cfg.get(i, opt)
            except:
                d[opt] = None

        if not "mailboxes" in d or d["mailboxes"] == "":
            d["mailboxes"] = DEFAULT_MAILBOX

        if "interval" in d:
            try:
                    d["interval"] = int(d["interval"])
            except: d["interval"] = INTERVAL
        else:
            d["interval"] = INTERVAL

        if not "server" in d or d["server"] == "":
            sys.stderr.write("%s will not be checked: " % d["name"])
            sys.stderr.write("server not defined in config file\n")
            continue
        if not "user" in d or d["user"] == "":
            sys.stderr.write("%s will not be checked: " % d["name"])
            sys.stderr.write("user not defined in config file\n")
            continue
        if not "password" in d or d["password"] == "":
            sys.stderr.write("%s will not be checked: " % d["name"])
            sys.stderr.write("password not defined in config file\n")
            continue

        l.append(d)

    return l

accounts = build_config()
if len(accounts) == 0:
    sys.stderr.write("No accounts defined, exiting..\n")
    sys.exit(1)

# daemonize
try:
    pid = os.fork()
except Exception as e:
    os.stderr.write("%s\n" % (e))
    sys.exit(1)

if pid == 0:
    os.setsid()

    try:
        pid = os.fork()
    except Exception as e:
        os.stderr.write("%s\n" % (e))
        sys.exit(1)

    if pid > 0:
        os.chdir("/")
        os.umask(0)
    else:
        os._exit(0)

else:
    os._exit(0)

if os.getuid() == 0:
    os.setuid(uid)

fd = resource.getrlimit(resource.RLIMIT_NOFILE)[1]
if fd == resource.RLIM_INFINITY:
    fd = MAXFD

sys.stdout.flush()
sys.stderr.flush()

devnull = os.open(DEVNULL, os.O_RDWR)

os.dup2(devnull, sys.stdin.fileno())
os.dup2(devnull, sys.stdout.fileno())
os.dup2(devnull, sys.stderr.fileno())

signal.signal(signal.SIGTERM, close_imap)

Notify.init(__name__)

for account in accounts:
    T = Account(account)
    T.loop()
